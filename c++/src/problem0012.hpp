#ifndef PROBLEM_12_HPP__
#define PROBLEM_12_HPP__
/*
 * The sequence of triangle numbers is generated by adding the natural numbers. So
 * the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten
 * terms would be:
 *
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 *
 * Let us list the factors of the first seven triangle numbers:
 *
 * 1: 1
 * 3: 1,3
 * 6: 1,2,3,6
 * 10: 1,2,5,10
 * 15: 1,3,5,15
 * 21: 1,3,7,21
 * 28: 1,2,4,7,14,28
 * We can see that 28 is the first triangle number to have over five divisors.
 *
 * What is the value of the first triangle number to have over five hundred divisors?
 */
#include <iostream>
#include <algorithm>
#include "prime_division.hpp"

template<typename T>
T triangle(T n)
{
  auto naturals = vector<T>(n + 1);
  iota(naturals.begin(), naturals.end(), static_cast<T>(0));

  return accumulate(naturals.begin(), naturals.end(),
    [](const T x, const T y) { return x + y; }
}

template<typename T>
vector<vector<T>> product(const vector<T>& first, const vector<vector<T>> rest)
{
  size_t result_length = first.size();

  foreach(rest.begin(), rest.end(), [&](vector<T> x) { result_length * x.size() });

  vector<vector<T>> result(result_length);
  vector<vector<size_t> indexes(result_length);
  fill(result.begin(), result.end(), 0);

  size_t indexes_index = 0;

  while (any_of(result.begin(), result.end(),
    [&](const vector<T> x) { return x.size() < rest.size(); }))
  {
    for (int i = 0; i < result_length / first.size(); ++i)
    {
      result[i].push_back = first.front();
    }
  }

  return result;
}

template<typename T, typename OutputIterator>
void factors(T n, OutputIterator results)
{
  map<T, T> factors_with_exponents = prime_division(n);
  vector<T> powers;
  foreach(factors_with_exponents.begin(), factors_with_exponents.end(),
    [&](const pair<T, T>& x) { powers.push_back(x.second); });

  vector<vector<T>> exponents;

  transform(powers.begin(), powers.end(), back_inserter(exponents),
    [](const T x)
    {
      vector<T> values(x + 1);
      iota(values.begin(), values.end(), static_cast<T>(0));

      return values;
    });

  product(exponents[0].begin(), exponents[0].end()
}

long problem12()
{
}

#endif

